---
layout: post
title: UI框架设计
---

# UI
UI是用来**展示数据**和**下达指令**，所有设计都是为了清晰展现数据和方便下达指令这2个目的。

---
## 概念
#### RectItem
界面中所有的元素都是RectItem，由原子RectItem组合成具有特定功能RectItem(Widget)，再由各种功能的Widget组合成面向业务的RectItem(Window)。
从下向上看，整个Window结构就是一颗树，根节点是window本身，其下是各种Widget，最下面的叶节点则是不可再分的RectItem。

#### 布局
布局的目的是确定每个RectItem所在的位置，由于布局空间可能会发生变化所以位置常常不仅由一个坐标决定，还涉及到排版。
排版主要是指定一个RectItem和另外一个RectItem的位置关系。通常的方式是为Rect定义9个关键点，然后拿源RectItem的某个关键点去对齐到目的RectItem的某个关键点。
当源RectItem有2个或者2个以上关键点设置了对齐，就会发生Resize，就像手机上的pinch操作。

#### Size
每个RectItem的大小可以直接指定(支持像素或者百分比)，也可以通过对齐点来计算，但是优先使用对齐点计算来的。

#### Widget
Widget是由原子RectItem组合而成。它可以用于展示特定数据结构，接收特定的用户输入。
Widget指定了能接收哪些用户输入，并触发相应的Widget事件。

#### Window
Window由多个Widget组合而成，用于向用户展示具体业务功能。

#### 屏幕适配
一套界面需要尽量多的适应不同的窗口尺寸(停靠)和不同的DPI(拉伸)。

* 暴力拉伸:
    定义一个设计分辨率，整个UI不改变高宽比去填充，如果屏幕高宽比和设计分辨率的高宽比对不上，则按规则填充黑边。
    这种方式简单粗暴，甚至不需要布局的自动对齐，全是绝对像素布局。
    适用于窗口尺寸一致，但是DPI碎片化的情况，比如手机。有一些PC游戏比如《shop heroes》也是如此。

* 拉伸大法2:
    和暴力拉伸不同的是，界面元素缩放后，不会用黑边填充，而是根据对齐规则停靠。
    适用窗口尺寸碎片化，DPI一致的情况，《魔兽世界》是这种方式。

* 最小窗口法：
    定义一套最小窗口尺寸，使得UI元素之间不会重叠，更改窗口尺寸后，UI元素按规则停靠，但不会进行缩放。
    适用窗口尺寸碎片化，DPI一致的情况，《群星》是这种方式。

---
## 数据展示
#### 动画
由Widget事件驱动，作用于RectItem，用于用户操作的反馈。
* 支持easing 动画

#### 皮肤
如果说RectItem构成骨骼，那皮肤就是骨骼上的蒙皮。抽象出皮肤的概念可以灵活定义特效和方便替换整个UI表现(风格)。 
* 支持多个层次
* 支持多RectItem状态
* 支持shader特效
* 支持帧动画
* 支持9宫格表示方式
* 支持颜色叠加

#### 数据更新
* 定时更新：
    window处于active的时候按一定频率去取最新的数据来刷新界面，缺点是数据和来源事件分离，表现会有所欠缺。
* 事件通知：
    界面监听数据改变的事件，事件到来时去取数据刷新。
* 数据绑定：
    绑定不算一种更新策略，只是将控件和数据源通过某种方式对接起来，减少代码量。

---
## 界面操作
* 消息传递：RectItem接收到用户操作，将其向父RectItem(Widget)传递，Widget先看自己是否能够处理，不能处理直接抛弃，处理过后可能将其转换成Widget事件向外抛。
* 事件处理：监听Widget抛出的事件，然后回调相应的注册函数

---
## 其它
#### 国际化
(略)
#### 富文本
(略)
#### 模板
(略)
